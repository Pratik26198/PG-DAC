
| **Algorithm Type**        | **Time Complexity**           | **Space Complexity**          | **Example Algorithms**               | **Applications**                                                                                                                                                                                                                                                                           | **Advantages**                                                                                  | **Disadvantages**                                                                              |
|----------------------------|-------------------------------|--------------------------------|---------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|
| **Sorting**                | O(n log n) (Merge Sort)       | O(n) (Merge Sort)             | Quick Sort, Merge Sort, Bubble Sort  | Sorting datasets in databases, ranking systems, leaderboard generation, searching optimization, organizing data in e-commerce, preprocessing for binary search, and data compression algorithms (e.g., Huffman Coding).                                  | Efficient for ordering data                                                                    | May require extra space (Merge Sort), unstable (Quick Sort in some cases)                     |
| **Searching**              | O(log n) (Binary Search)     | O(1)                          | Binary Search, Linear Search         | Finding records in databases, locating a word in a dictionary, searching files in directories, searching in search engines, AI decision-making, text autocomplete systems, and geographic data lookup.                                                | Fast for sorted data                                                                           | Requires sorted data (Binary Search), slower for unsorted data (Linear Search)                |
| **Dynamic Programming**    | O(2^n) (Naive) or O(n^2)     | O(n)                          | Fibonacci, Knapsack, Longest Subsequence | Resource allocation, route optimization, computational biology (gene sequencing, protein folding), financial modeling, inventory management, game theory, scheduling problems, and combinatorial optimization problems.                                  | Solves complex problems by breaking them into smaller subproblems                             | Requires significant memory, sometimes complex to implement                                   |
| **Graph Algorithms**       | O(V+E) (BFS, DFS)            | O(V)                          | Dijkstra's, Kruskal's, Prim's        | Network routing (e.g., internet routing protocols), social network analysis, shortest path problems, airline route optimization, delivery systems (e.g., Amazon logistics), road mapping (e.g., Google Maps), and dependency resolution in build systems. | Finds optimal paths in graphs                                                                  | Can be computationally expensive for dense graphs                                             |
| **Divide and Conquer**     | O(n log n)                   | O(log n)                      | Merge Sort, Quick Sort, Binary Search | Efficient data sorting (e.g., search engines), solving recurrence problems in algorithms, game optimization (e.g., chess), matrix multiplication in scientific computing, and large-scale computational problems in physics and chemistry.                | Simplifies complex problems into smaller subproblems                                           | Recursive approach can lead to stack overflow if not implemented carefully                    |
| **Greedy Algorithms**      | O(n log n)                   | O(1)                          | Huffman Coding, Kruskal's, Prim's    | Compression algorithms (e.g., JPEG, Huffman Coding), minimum spanning tree generation, coin change problem, scheduling tasks, job sequencing, delivery optimization, and coding problems in competitive programming.                                     | Simple and efficient for many problems                                                        | May not always produce the optimal solution                                                   |
| **Backtracking**           | O(2^n)                       | O(n)                          | N-Queens, Sudoku Solver              | Puzzle solving (e.g., Sudoku, N-Queens), generating permutations/combinations, maze solving, decision-making problems, AI in games (e.g., chess), and DNA sequencing in computational biology.                                                         | Finds all solutions to a problem                                                              | Exponential time complexity for large inputs                                                  |
| **Branch and Bound**       | Varies depending on pruning  | Varies                        | Travelling Salesman Problem (TSP)    | Optimization problems (e.g., TSP, knapsack), finance (e.g., portfolio optimization), scheduling (e.g., minimizing makespan), logistics and supply chain management, and AI (e.g., decision trees).                                                     | Produces optimal solution                                                                      | Requires careful pruning to be efficient                                                      |
| **Machine Learning**       | O(n^3) (Training)            | Varies                        | Gradient Descent, k-NN, SVM          | Pattern recognition, recommendation systems, fraud detection, natural language processing (NLP), autonomous driving, stock market prediction, facial recognition, spam detection, and sentiment analysis.                                              | Enables data-driven decision-making                                                            | Computationally expensive, requires large datasets                                            |
| **String Matching**        | O(m+n)                       | O(m+n)                        | KMP, Rabin-Karp, Boyer-Moore         | Text searching in documents, plagiarism detection, DNA sequencing, pattern matching in text editors, spam filters, auto-complete systems, and search engines.                                                                                         | Efficient for pattern matching                                                                 | Implementation can be complex                                                                 |
| **Cryptography**           | O(n^3) (RSA)                 | O(n^2)                        | RSA, AES, DES                        | Secure communications (e.g., HTTPS, email encryption), blockchain, digital signatures, secure online transactions, VPNs, and data protection in cloud storage.                                                                                         | Provides security and privacy                                                                  | Computational overhead for encryption and decryption                                          |
| **Linear Programming**     | Varies (Simplex: Exponential)| Varies                        | Simplex, Interior-Point Methods      | Resource allocation, logistics and supply chain management, network flow optimization, financial portfolio optimization, energy distribution, and production planning in manufacturing.                                                                | Solves real-world optimization problems efficiently                                            | Complexity increases with problem size                                                        |

