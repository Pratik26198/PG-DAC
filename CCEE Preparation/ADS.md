| **Algorithm Type**        | **Algorithm Examples**          | **Best Case**                | **Average Case**                | **Worst Case**                | **Space Complexity**          | **Applications**                                                                                                                                                                                                                                                                           | **Advantages**                                                                                  | **Disadvantages**                                                                              |
|----------------------------|----------------------------------|------------------------------|----------------------------------|--------------------------------|--------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|
| **Sorting**                | **Bubble Sort**                 | O(n)                         | O(n²)                           | O(n²)                         | O(1)                          | Sorting datasets in databases, ranking systems, and organizing e-commerce data.                                                                                                                                 | Simple to implement                                                                             | Inefficient for large datasets                                                                 |
|                            | **Selection Sort**              | O(n²)                        | O(n²)                           | O(n²)                         | O(1)                          | Useful for small datasets.                                                                                                                                                                                     | Easy to understand                                                                             | Always performs O(n²) operations regardless of the input size                                  |
|                            | **Insertion Sort**              | O(n)                         | O(n²)                           | O(n²)                         | O(1)                          | Suitable for nearly sorted data.                                                                                                                                                                               | Efficient for small datasets                                                                   | Inefficient for large datasets                                                                 |
|                            | **Merge Sort**                  | O(n log n)                   | O(n log n)                      | O(n log n)                    | O(n)                          | Large dataset sorting, stable sorting.                                                                                                                                                                          | Stable and efficient                                                                           | Requires additional memory                                                                     |
|                            | **Quick Sort**                  | O(n log n)                   | O(n log n)                      | O(n²)                         | O(log n)                      | General-purpose sorting.                                                                                                                                                                                       | Fast on average                                                                               | Poor pivot selection leads to worst-case performance                                           |
|                            | **Heap Sort**                   | O(n log n)                   | O(n log n)                      | O(n log n)                    | O(1)                          | Priority queue implementation and sorting.                                                                                                                                                                      | Memory efficient                                                                              | Slightly slower than Merge Sort for large datasets                                             |
| **Searching**              | **Linear Search**               | O(1)                         | O(n)                            | O(n)                          | O(1)                          | Searching unsorted datasets.                                                                                                                                                                                   | Simple to implement                                                                             | Inefficient for large datasets                                                                 |
|                            | **Binary Search**               | O(1)                         | O(log n)                        | O(log n)                      | O(1)                          | Finding elements in sorted datasets, AI decision trees, and text autocomplete.                                                                                                                                 | Highly efficient for sorted data                                                               | Requires sorted data                                                                           |
| **Tree Operations**        | **BST Search, Insert, Delete**  | O(log n)                     | O(log n)                        | O(n)                          | O(h)                          | Database indexing, hierarchical data structures.                                                                                                                                                                | Efficient for balanced trees                                                                   | Performance degrades for skewed trees                                                         |
| **Graph Algorithms**       | **BFS**                         | O(V + E)                     | O(V + E)                        | O(V + E)                      | O(V)                          | Network routing, social network analysis, and road mapping.                                                                                                                                                    | Simple and useful for traversing graphs                                                       | Inefficient for large, dense graphs                                                           |
|                            | **DFS**                         | O(V + E)                     | O(V + E)                        | O(V + E)                      | O(V)                          | Used for topological sorting and detecting cycles.                                                                                                                                                              | Useful for exploring all nodes                                                                | Stack overflow for large recursive calls                                                      |
|                            | **Dijkstra’s Algorithm**        | O(V + E log V)               | O(V + E log V)                  | O(V + E log V)                | O(V)                          | Finding shortest paths in road maps, delivery systems, and routing protocols.                                                                                                                                  | Provides efficient solutions                                                                  | Does not handle negative edge weights                                                         |
|                            | **Kruskal’s Algorithm**         | O(E log V)                   | O(E log V)                      | O(E log V)                    | O(V)                          | Generating Minimum Spanning Trees in network designs.                                                                                                                                                          | Efficient for sparse graphs                                                                    | Requires sorting edges                                                                         |
| **Dynamic Programming**    | **Fibonacci Sequence**          | O(n)                         | O(n)                            | O(n)                          | O(n)                          | Resource allocation, inventory management, and combinatorial optimization.                                                                                                                                      | Reduces redundant calculations                                                                | Memory-intensive for large inputs                                                             |
|                            | **Knapsack Problem**            | O(2^n)                       | O(n*W)                          | O(n*W)                        | O(n*W)                        | Resource optimization and scheduling tasks.                                                                                                                                                                     | Effective for small input sizes                                                               | Computationally expensive for large inputs                                                    |
|                            | **Longest Subsequence**         | O(n²)                        | O(n²)                           | O(n²)                         | O(n)                          | Gene sequencing, text comparisons, and version control tools.                                                                                                                                                  | Solves subsequence problems efficiently                                                       | Inefficient for large datasets                                                                 |
| **Divide and Conquer**     | **Merge Sort**                  | O(n log n)                   | O(n log n)                      | O(n log n)                    | O(log n)                      | Sorting, matrix multiplication, and solving recurrence relations.                                                                                                                                              | Simplifies complex problems into smaller subproblems                                          | May cause stack overflow for deep recursion                                                   |
|                            | **Binary Search**               | O(1)                         | O(log n)                        | O(log n)                      | O(1)                          | Efficient searching in sorted data.                                                                                                                                                                             | Highly efficient for large datasets                                                           | Requires sorted data                                                                           |
| **Backtracking**           | **N-Queens Problem**            | O(1)                         | O(2^n)                          | O(2^n)                        | O(n)                          | Puzzle solving, combinatorial generation, and AI strategies.                                                                                                                                                   | Finds all solutions to a problem                                                              | Exponential complexity for large inputs                                                       |
|                            | **Sudoku Solver**               | O(1)                         | O(2^n)                          | O(2^n)                        | O(n)                          | Game puzzles and constraint satisfaction problems.                                                                                                                                                              | Handles intricate logical constraints                                                         | Computationally intensive for large boards                                                    |
| **Hashing**                | **Search, Insert, Delete**      | O(1)                         | O(1)                            | O(n)                          | O(1)                          | Fast lookups in dictionaries, caching, and database indexing.                                                                                                                                                  | Provides average constant-time performance                                                   | Collisions degrade performance to linear time                                                 |
| **Heap Operations**        | **Insert/Delete**               | O(log n)                     | O(log n)                        | O(log n)                      | O(1)                          | Priority queues, graph algorithms like Dijkstra, and memory management.                                                                                                                                        | Efficient for priority-based tasks                                                            | Limited use outside priority queue scenarios                                                  |
|                            | **Find Max/Min**                | O(1)                         | O(1)                            | O(1)                          | O(1)                          |                                                                                                                                                                                                               | Very fast for max/min lookups                                                                 | Restricted to heap structure                                                                  |
